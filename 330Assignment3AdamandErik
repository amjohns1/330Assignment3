"""
Class: CS 330
Authors: Adam Johnson & Erik Overberg
Program: Assignment 3
"""

from typing import List
from heapq import heappush, heappop

    
    
"""Defining function for A* Algorithm"""
def pathfind_AStar(graph, start, goal, heuristic):
    
    class NodeRecord:
        def __init__(self, node: int = 0, connection: str = None, cost_so_far: float = 0.0, estimated_total_cost: float = 0.0):
            self.node = node
            self.connection = connection
            self.cost_so_far = cost_so_far
            self.estimated_total_cost = estimated_total_cost
            
        def __lt__(self, other):
            return self.estimated_total_cost < other.estimated_total_cost
    
    
    """initialize the record for start node"""
    start_record = NodeRecord(start, None, 0, heuristic(start, goal))
    """Initialize the open and closed lists"""
    open_list = [start_record]
    closed_list = []
    
    """Itirate through processing each node"""
    while open_list:
        """Find the smallest eleement in the open list using estimated_total_cost"""
        current_record = heappop(open_list)
        
        """If it is the goal node, then terminate"""
        if current_record.node == goal:
            break
        
        """otherwise get its outgoing connections"""
        connections = graph.getConnections(current_record.node)
        
        """Loop through each connection"""
        for connection in connections:
            """Get the cost estimate for the end node"""
            end_node = connection.to_node
            end_node_cost = current_record.cost_so_far + connection.cost
            
            """if the node is closed we may have to skip, or remove it from the closed list"""
            end_node_record = None
            for record in closed_list:
                if record.node == end_node:
                    end_node_record = record
                    break
            
            if end_node_record and end_node_record.cost_so_far <= end_node_cost:
                continue
            
            if end_node_record:
                closed_list.remove(end_node_record)
            
            """We can use the node's old cost values to calculate its heuristic without 
            calling the possibly expensive heuristic function"""
            end_node_heuristic = end_node_record.heuristic.estimated_total_cost - end_node_record.cost_so_far if end_node_record else heuristic(end_node, goal)
            
            
            """skip if the node is open we've not found a better route"""
            for record in open_list:
                if record.node == end_node and record.cost_so_far <= end_node_cost:
                    break
            
            else:
                """otherwise we we've got an unvisited node, so make a record for it"""
                end_node_record = NodeRecord(end_node, connection)
                
                """we need to calculate the heuristic value using the function, since we do not have an existing
                record to use"""
                
                """and add it to the open list"""
                heappush(open_list, end_node_record)
            
            """ we have finisged looking at the connections for the current node, so add it
            to the closest list and remove it from the open list"""
            
    """We're here if we've either found the goal, or if we've no more nodes to search."""
    if current_record.node != goal:
        """we have run out of nodes withput finding the goal, so there is nothing to return"""
        return None
    
    else:
        """Compile the list of connections in the path"""
    path = []
    
    """work back along the path, accumulating connections"""
    while current_record.node != start:
        path.append(current_record.connection)
        current_record = current_record.connection.getFromNode
    """reverse the path"""
    return list(reversed(path))
    
    